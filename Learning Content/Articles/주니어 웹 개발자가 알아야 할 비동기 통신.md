[주니어 웹 개발자가 알아야 할 비동기 통신](https://yozm.wishket.com/magazine/detail/1982/)

# 비동기 처리란 무엇인가요?

- 프로세스의 완료를 기다리지 않고 동시에 다른 작업을 처리하는 방식을 말합니다.
- 싱글스레드로 작동된다는 것은 동시에 두개의 함수가 실행될 수 없고 한번에 하나의 함수만 실행할 수 있다는 의미입니다.
- 비동기 처리는 이전 함수의 종료를 기다릴 필요가 없는 경우 다음 함수를 바로 실행하여 작업의 효율을 높이기 위해 필요합니다.

# 모던 브라우저는 어떻게 비동기 로직을 처리하나요?

- 대표적으로 fetch와 같은 비동기 처리를 지원하는 Web API를 사용하면 해당 비동기 로직은 브라우저의 다른 스레드에서 처리됩니다.
- 비동기 함수는 CallStack에 쌓이지 않고 곧바로 사라지고, 비동기 처리가 완료된 이후 동작에 대한 callback function은 별도의 Message Queue에 추가됩니다.
- 브라우저의 이벤트 루프에 따라 CallStack이 비었을 때 Message Queue에 추가되었던 Task(callback function)이 CallStack에 추가됩니다.
- 위와 같은 비동기 처리 방식을 통해 비동기 함수가 처리되는 동안에 CallStack은 이 작업이 완료될 때까지 기다리지 않고 다음 Task를 수행하게 됩니다.

# 자바스크립트로 비동기 로직을 어떻게 작성하나요?

- 과거에는 Callback을 활용하여 비동기 로직을 작성하였습니다. 그러나 이 방식은 한계가 있어 Promise 패턴, async/await 등을 활용하는 방식으로 발전했습니다.

### 1. Callback
- 콜백지옥: 콜백 중첩으로 비동기를 처리하는 경우 콜백의 콜백의 콜백으로 중첩해서 호출하면서 콜백 함수의 depth가 깊어집니다.
- 콜백 함수의 depth가 깊어지면 어떤 문제가 있나요?
	1. 에러 핸들링이 어려워집니다
		- 예를 들어 depth가 깊다면 CallStack을 기준으로 안쪽 스택에서 발생한 에러가 바깥까지 전파되지 않을 수 있습니다. (에러가 전파되기 전에 콜스택에서 먼저 제거되기 때문입니다.)

	1. 코드의 가독성이 떨어집니다.

### 2. Promise 패턴
- Promise 객체를 활용하여 비동기 로직을 작성할 수 있습니다. 
- Promise 객체는 인자로 Promise 생성자 함수를 받고, 프로미스 생성자 콜백 함수는 첫번째 인자로 `resolve`, 두번째 인자로 `reject`를 받습니다.
- Promise 객체는 생성될 때 생성자 함수가 바로 실행됩니다. 즉, 프로미스 생성자 함수는 동기적으로 실행됩니다. 
- 비동기 함수의 성공과 실패 여부를 `then`과 `catch`라는 별도의 block으로 구분해서 받습니다.
	- `then` block에는 `resolve` 결과를 받고, `catch` block에는 `reject` 결과를 받습니다.
- Promise 객체의 static method로는 `all`, `allSettled`가 있습니다.
	1. `Promise.all` : 여러 개의 비동기 함수를 병렬로 수행할 수 있습니다.
	1. `Promise.allSettled` : 비동기 함수가 모두 완료된 후에 수행합니다.
	1. 둘의 차이점은 무엇인가요? `Promise.all`은 하나라도 비동기 함수가 실패하는 경우 성공한 응답이 있더라도 바로 `catch` block으로 빠지게 됩니다. 
	1. 정리하자면, 전체 비동기 함수가 모두 성공을 보장해야 하는 경우(모든 프로미스가 fulfilled 상태)에는 `Promise.all`을, 성공 실패 여부와 무관하게 이행된 결과를 원하면 `promise.allSettled`를 사용하면 됩니다.

### 3. async/await
- 비동기 로직을 포함한 경우에 비동기 처리가 완료된 후(처리가 완료되기를 기다린 후) 이어서 Task를 수행하고 싶다면? 비동기 작업이 완료될 때까지 기다린 후(await) 콜백 함수의 결과값을 받은 다음 이어서 Task를 수행합니다.
- `await`가 포함된 함수는 `async` 예약어를 붙여서 선언해야 합니다.
- `async` 비동기 함수는 Promise 객체를 반환합니다.

# 동기 비동기의 차이가 무엇인가요?

- 동기(Sync)와 비동기(Async)는 함수의 수행 시점에 차이가 있습니다.
- 메인 함수(caller)와 함수 내부에서 호출한 서브 함수(callee)가 있을 때,

### 1. 동기적인 로직
- 메인 함수가 서브 함수의 실행 결과를 기다렸다가 처리 결과를 확인한 후 다음 Task를 수행합니다.

### 2. 비동기적인 로직
- 메인 함수가 서브 함수를 호출하긴 하지만 실행 결과를 기다리지 않고 다음 Task를 수행합니다.
- 메인 함수의 다음 Task와 서브 함수가 동시에 실행됩니다.

# 블로킹Blocking과 논블로킹Non-Blocking의 차이가 무엇인가요?

- caller와 callee 함수의 제어권(함수를 실행할 권리)에 차이가 있습니다.

### 1. 블로킹Blocking 방식
- callee가 끝까지 실행된 후 제어권을 caller에게 돌려줍니다.

### 2. 논블로킹Non-Blocking 방식 
- callee가 실행되고 caller에게 바로 제어권을 돌려줍니다.

## 그렇다면 논블로킹 방식에서 callee는 제어권이 없는데 이후 태스크를 어떻게 수행하나요?

### 싱글 스레드: 이벤트 루프
- 그러나 자바스크립트와 같이 싱글 스레드로 동작하는 경우 비동기 함수 callee는 곧바로 제어권을 돌려주되, 이벤트 루프에 의해 처리됩니다. 앞서 살펴보았듯이 비동기 처리 이후 태스크인 콜백 함수는 Message Queue에 등록되어 대기하다가 이벤트 루프에 CallStack으로 올라가 처리됩니다.

### 멀티 스레드
- 리눅스 I/O 환경과 같은 멀티 스레드 환경에서는 사용자 스레드가 System Call로 요청을 보내면 커널 스레드가 생성되어 태스크가 수행되고, 제어권을 사용자 스레드에게 바로 다시 돌려줍니다.
- 즉, 스레드를 여러개 생성하여 각각이 제어권을 가지고 함수를 수행합니다.

# 적용할 점

- 적절하게 동기, 비동기 처리를 하여 불필요한 블로킹이 발생하지 않도록 주의해야 한다.