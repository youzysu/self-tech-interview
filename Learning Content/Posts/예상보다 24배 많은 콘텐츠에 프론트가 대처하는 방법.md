> [RIDI의 '예상보다 24배 많은 콘텐츠에 프론트가 대처하는 방법'](https://ridicorp.com/story/ridi-markdown-improvements/?ref=codenary)
## 1. 문제 상황

- 기존 컴포넌트 재사용 불가

1. 한 페이지에 250개 -> 6000개
2. 장르 탭, 필터링, 실시간 이벤트 참여 금액, 장바구니 추가 필요
3. 렌더링 속도 개선 필요: 10초 소요 (10MB)

## 2. 원인 분석 및 각 원인 별 해결 방안

### 2-1. 렌더링 최적화

- 라이트하우스 분석 결과 6만 여개의 element가 한번에 렌더링되고 있음
- 해결 방안: 리스트 가상화(윈도잉)를 위해 라이브러리 적용
  라이브러리 비교 테스트를 통해 선택
- 스켈레톤 UI 적용: 스켈레톤 SVG element를 동적으로 생성

### 2-2. 데이터 최적화

1. gzip 적용하여 압축

- 1/8 용량으로 압축
- 8.5MiB(8.91MB) -> 900KiB(921KB)

2. 필터링 데이터

- Suspense의 스켈레톤을 보여주고 데이터가 다 로드되면 렌더링
- startTransition 적용하면? 기존 데이터로 계속 보여주다가 새로운 데이터가 로드되면 업데이트할 수 있음
- 실제로는 startTransition을 제거하여 스켈레톤을 보여줘서 바로 로딩되는 것처럼 눈속임을 하고, 데이터가 로드되면 업데이트하는 방식으로 변경

3. 필터링 로직 수정

- 필터링 데이터 서버 요청 -> 프론트에서 필터링 작업 수행

### 2-3. 필터링 로직 최적화 필요

**1. 필터링 로직이 느린 이유 분석**

- 결론: ID가 10자리의 임의의 숫자인 Object를 스프레드로 복사한 후 새로운 속성을 추가하는 경우 느림
- 분석: 프로파일링을 진행하여 성능 분석 필터링 로직 수행 시 CPU 사용량이 많음
- 개선: 일반 Object 대신 Map 자료구조로 변경, 복사하지 않고 사용

**WHY?**

- V8 내부에서 사용하는 Object 차이
  - 객체의 속성을 저장하는 방식이 다름
  - HOLEY_ELEMENTS: 객체의 속성이 연속된 메모리 위치에 저장되지 않고, 구멍(hole)이 있는 배열과 유사한 데이터 구조에 저장
  - DICTIONARY_ELEMENTS: 일반적인 사전(dictionary)과 유사한 데이터 구조로, 객체의 속성이 키-값 쌍 형태로 저장됨을 의미합니다. 이는 주로 객체에 많은 수의 속성이 동적으로 추가되는 경우에 사용

**V8 내부적으로 Object를 처리하는 방식**

- ID가 연속된 숫자인 경우 HOLEY_ELEMENTS를 사용하고,
- ID가 임의의 숫자인 경우 DICTIONARY_ELEMENTS를 사용

## 후기

- 이렇게 원인을 다각도로 분석해보고, 각 원인 별로 해결 방안을 고민해서 적용하는 게 인상적이었다!
- V8 엔진 내부에서 사용하는 Object 종류에 대해서도 알게 되었고, 실제로 성능 문제로 인해 V8 엔진 내부 동작까지 분석해야 하는 상황이 발생했을 때 어떻게 해결할 수 있을지에 대한 힌트를 얻었다.
