## 정리
### 소프트웨어 모듈이 가져야 하는 세가지 기능 (p.14)
- 모듈: 크기와 상관 없이 클래스, 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소

1. 실행 중에 제대로 동작하는 것 (모듈의 존재 이유)
2. 변경을 위해 존재하는 것
3. 코드를 읽는 사람과 의사소통 하는 것: 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.

### 의존성 (p.16)
- 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.
- 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이 우리가 애플리케이션의 기능을 구현하는 목적이다.
- 단, **필요한 최소한의 의존성만 유지**하고 **불필요한 의존성을 제거**하는 것이다.

### 결합도Coupling (p.17)
- 객체 간 의존하는 정도
- 객체들이 합리적인 수준으로 의존하는 경우, 결합도가 낮다.
- 객체 사이의 의존성이 과한 경우, 결합도가 높다.
- (p.18) 객체A가 객체B 내부의 프로퍼티에 직접 접근한다는 것은 객체A가 객체B에 결합된다는 것을 의미한다. = 객체B를 변경할 때 객체A도 함께 변경해야 한다. = 변경사항이 많아지면 변경하기도 어렵고, 버그가 생길 확률이 높아진다.

### 캡슐화Encapsulation (p.20)
- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것
- 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다. 내부를 알아야 할 필요가 없다.
- 캡슐화를 통해 객체와 객체 사이의 결합도를 낮춘다.

### 인터페이스와 구현을 구분하고 인터페이스에만 의존하도록 한다. (p.21)
- 자기 자신의 문제를 스스로 해결하도록 코드를 작성한다.
- 객체 내부의 변경이 객체 외부에 파급되지 않도록 제어한다.

### 응집도Cohesion (p.21)
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 것

### 책임
- 책임은 객체지향 프로그래밍에서 **기능**을 가리키는 용어로 생각해도 무방하다.
- 각 객체는 자신을 스스로 책임져 책임이 적절하게 분배된다.

### 객체지향 프로그래밍 OOP
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식
- 캡슐화를 이용하여 의존성을 적절하게 관리하여 객체 사이의 결합도를 낮추는 것
- 적절한 객체에 적절한 책임을 할당하여 다른 객체와의 협력이라는 문맥 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다.

### 설계를 게 만드는 것은 의존성이라는 것을 기억하라.(p.29) 
- 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮춰야 한다.
- 몰라도 되는 세부사항(구현)을 객체 내부로 감춰 캡슐화하여 결합도를 낮출 수 있다.
- 캡슐화는 객체의 자율성을 높여 낮은 결합도와 높은 응집도를 가진 객체가 다른 객체와 협력하도록 한다. 최소한의 의존성만 남기는 것

### 의인화Anthropomorphism (p.33)
- 현실에서는 수동적인 존재라고 하더라도 모든 것을 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙
- **모든** 객체들이 자율적으로 행동하는 설계

### 설계 (p.34)
- 설계란 코드를 배치하는 것이다[Metz12].
- 좋은 설계란 오늘 완성해야 하는 기능을 구현하는 코드이면서 동시에 내일 쉽게 변경할 수 있는 코드
	- 변경하기 쉬운 설계는 적게 최소한의 범위로 변경하면 되는 것

## 스터디 후기

- 아무래도 컴포넌트의 책임과 역할에 대한 이야기를 뺴놓을 수 없었다.
- 그 중 데이터 페칭만을 위한 계층을 별도로 두어 UI 컴포넌트는 순수하게 렌더링의 책임만 수행하도록 하는 것에 대한 의견을 나눴다. 
	- 해당 컴포넌트와 관련된 API 호출하는 로직을 custom hook으로 분리했다면 오히려 같이 두는게 실제 구현이나 유지보수에서도 더 편하지 않은지
	- 그러면 리액트는 사실상 UI 라이브러리라는 점에서 책임을 넘어선 것은 아닌지, 컴포넌트의 책임이 비대해지는게 아닌지
	- 사실상 애플리케이션 규모가 커지면 UI 컴포넌트는 최대한 순수하게 가져가는게 유지보수 측면에서 유리할 것이라는 생각
	- API 호출을 어느정도로 나누는게 좋은지
	- CRA에서는 response data의 크기가 커지는 것보다 네트워크 요청 수가 많은게 더 자연스러운 것 같다.
- 추상화와 캡슐화의 개념에 대해서도 많은 이야기를 나눴고!
- 좋은 설계가 지향하는 바는 객체지향이든 함수형이든 비슷하고, 제시하는 패러다임의 차이일 뿐이라는 생각이 들었다!
- 앞으로도 기대된다!