## 개념
- 함수가 자신이 생성될 때의 스코프에서 참조하는 변수를 기억하는 현상
- 어떤 함수에서 선언한 **변수를 참조하는 내부 함수**를 외부로 전달한 경우, 함수를 선언한 함수의 실행 컨텍스트가 종료된 이후에도 함수에서 선언한 변수가 사라지지 않는 현상
- 이후에 함수를 호출할 때 클로저에 의해 가비지 컬렉팅되지 않고 메모리에 남겨진 변수를 여전히 참조하여 사용 가능

## 활용 예시
1. 콜백함수에서 외부 변수를 참조하기 위해
2. 정보 은닉을 위해 외부에 제공하지 않는 private 변수나 메서드를 만들어 접근 권한을 제어하기 위해
3. debounce 함수에서 관리하는 timeoutId 변수를 함수 간 독립적인 상태를 유지하기 위해
4. 여러 개의 인자를 받는 함수를 단일 인자를 받는 여러 함수로 변환하는 **커링 함수를 구현**하기 위해
	- 클로저로 각 단계에서 받은 인자들을 마지막 단계에서 참조하기 전까지 기억
5. React useState hook의 상태 관리 방법 ([🔗 블로그 링크](https://zoey-dev-log.vercel.app/devlog/react-useState))
- 컴포넌트의 **렌더링 사이클 간 상태값을 유지**하기 위해 클로저 활용
- 클로저로 컴포넌트에서 호출한 hook의 결과값(`[state, setState]` 튜플)을 저장﹒참조
- 렌더 트리에서의 컴포넌트의 위치와 클로저에 저장해둔 상태를 연결하는 방법
	- 컴포넌트에서 Hook이 호출된 순서에 따라 이에 맞는 상태를 참조
	- 현재 컴포넌트에서 hook이 호출된 순서(index)를 관리

#### 관련 질문
- 이미 실행이 종료된 상태인 함수임에도 불구하고 어떻게 함수의 실행 컨텍스트에 접근할 수 있나요?
	- 가비지 컬렉터의 동작 방식
	- 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값을 수집 대상에 포함시키지 않음
	- 실행 컨텍스트 중 내부 함수에서 참조하는 변수만 남겨두고 나머지는 가비지 컬렉터가 수집하도록 최적화
- 클로저를 활용할 때 유의해야 할 점
	- **메모리 관리**: **의도하지 않은 메모리 누수**가 발생하지 않도록 유의해야 함
	- 클로저 현상에 의해 메모리에 남은 변수를 사용할 필요가 없어졌을 때 메모리 해제되도록 해야 함
	- 해당 변수의 참조 카운트 Reference Count를 0으로 만들어야 함
	- 해당 변수에 **참조형이 아닌 원시형(null, undefined) 할당**

## 참고자료
- 코어 자바스크립트