## 개념
- 클로저란 **함수가 자신이 생성될 때의 스코프에서 참조하는 변수를 기억하는 현상**을 말합니다.
	- 이후에 함수를 호출할 때 클로저에 의해 가비지 컬렉팅되지 않고 메모리에 남겨진 변수를 여전히 참조하여 사용할 수 있게 됩니다.
- 어떤 함수에서 선언한 **변수를 참조하는 내부 함수**를 외부로 전달한 경우, 함수를 선언한 함수의 실행 컨텍스트가 종료된 이후에도 함수에서 선언한 변수가 사라지지 않는 현상을 의미합니다.
## 활용 예시
- 클로저는 다양하고 광범위하게 활용되고 있습니다.
1. 콜백함수에서 외부 변수를 참조하기 위해
2. 정보 은닉을 위해 외부에 제공하지 않는 private 변수나 메서드를 만들어 접근 권한을 제어하기 위해
3. debounce 함수에서 관리하는 timeoutId 변수를 함수 간 독립적인 상태를 유지하기 위해
4. 여러 개의 인자를 받는 함수를 단일 인자를 받는 여러 함수로 변환하는 **커링 함수를 구현**하기 위해
	- 클로저로 각 단계에서 받은 인자들을 마지막 단계에서 참조하기 전까지 기억할 수 있습니다.
5. React에서 useState로 상태값을 관리할 때
### React useState ([🔗 블로그 링크](https://zoey-dev-log.vercel.app/devlog/react-useState))
- 클로저를 활용한 대표적인 예시는 리액트의 useState 훅입니다.
- 컴포넌트의 **렌더링 사이클 간 상태값을 유지**하고, 상태값이 변경될 때 업데이트하여 관리하기 위해 클로저를 활용하여 필요한 값을 저장하고 참조합니다.
	- 현재 렌더링 중인 컴포넌트에서 몇 번 hook이 호출되었는지에 대한 인덱스 값(`currentHookIndex`)과 컴포넌트에서 호출한 hook의 결과값(`[state, setState]` 튜플)을 저장해두고 참조합니다.
#### 관련 질문
- 이미 실행이 종료된 상태인 함수임에도 불구하고 어떻게 함수의 실행 컨텍스트에 접근할 수 있나요?
	- 가비지 컬렉터의 동작 방식 때문에 가능합니다. 
	- 가비지 컬렉터는 어떤 값을 참조하는 변수가 하나라도 있다면 그 값을 수집 대상에 포함시키지 않기 때문입니다. 
	- 단, 실행 컨텍스트 중 내부 함수에서 참조하는 변수만 남겨두고 나머지는 가비지 컬렉터가 수집하도록 최적화되어 있습니다.
- 클로저를 활용할 때 유의해야 할 점이 있을까요?
	- **의도하지 않은 메모리 누수**가 발생할 수 있어 **메모리 관리**에 유의해야 합니다.
	- 따라서 클로저 현상에 의해 메모리에 남은 변수를 사용할 필요가 없어졌을 때 메모리를 차지하지 않도록 관리해야 합니다.
	- 해당 변수에 **참조형이 아닌 원시형(null, undefined)을 할당**하여 **참조 카운트를 0으로** 만들어줍니다.

## 참고자료
- 코어 자바스크립트